---
title: "Gary's analysis"
author: "Gary Sztajnman"
date: "February 16, 2016"
output: pdf_document
---

/section{Hypothesis}

Global warming is partly to blame for these heavy rainfall events. Because warmer air can hold more moisture, heavier precipitation is expected in the years to come.
According to the Intergovernmental Panel on Climate Change ( IPCC), the atmosphere is about 0.75 degrees warmer than it was at the start of the century, which means it can hold 5-6 per cent more moisture.



```{r}
library(gdata)
library(scales)
library(chron)
library(RColorBrewer)
library(lattice)
library(ncdf4)
library(maps)
library(ggplot2)
library(ggmap)

workdir ="/Users/garyair/Desktop/Dropbox/Columbia/EDA/P2/Edav-project-2/Edav-project-2/Data"
setwd(workdir)

flood = read.csv("cleanGlobalFloodData.csv")
View(flood)

Dev = read.csv("2015_development index.csv")

flood2 <- read.csv("cleanGlobalFloodDataWithRegionsfiltered-Index noNA.csv")
View(flood2)

## Adding a year column
date1<- as.Date(flood$dateBegan,"%m/%d/%Y")
flood$year<-as.numeric(format(date1, "%Y"))

## Add other to mainCause1

flood2$GNIPerCapita <- as.numeric(flood2$GNIPerCapita)

flood2$region[]
flood$mainCause1 <- factor(flood$mainCause1)

plot(flood2$HDI)


flood2$HDIclass <- cut(flood2$HDI,
                     breaks=c(-Inf, 0.6, 0.75, Inf),
                     labels=c("low","medium","high"))
summary(flood2$HDIclass)
plot(flood2$HDIclass)

## Severity by year:
ggplot(data = flood2, aes(year, magnitude, fill=severity)) +
  stat_summary(fun.y = "mean", geom = "bar")  # or "line" 

## Graph by cause
ggplot(data = flood2, aes(year, magnitude, fill=mainCause1)) +
  stat_summary(fun.y = "sum", geom = "bar")  # or "line" 

## Graph by cause except Heavy rain
ggplot(subset(flood2, mainCause1 != "Heavy Rain")) +
  aes(year, magnitude, fill=mainCause1) +
  stat_summary(fun.y = "sum", geom = "bar")


## Type of flood by continent
ggplot(subset(flood2)) +
  aes(year, magnitude, fill=mainCause1) +
  stat_summary(fun.y = "sum", geom = "bar") +
  facet_wrap(~region, ncol = 10)



ggplot(subset(flood2)) +
  aes(year, magnitude, fill=HDIclass) +
  stat_summary(fun.y = "sum", geom = "bar") +
  facet_wrap(~region, ncol = 3)

ggplot(subset(flood2)) +
  aes(year, peopleDead, fill=HDIclass) +
  stat_summary(fun.y = "sum", geom = "bar") 

## Trying to predict magnitude
summary(lm(magnitude ~ mainCause1, data = flood2))



## Trying to predict peopleDead
summary(lm(peopleDead ~ mainCause1, data = flood2))

summary(lm(peopleDead ~ magnitude + durationDays, data = flood2))

summary(lm(peopleDead ~ HDI + lifeExp + yearsSchool + GNIPerCapita, data = flood2))

summary(lm(peopleDead ~ GNIPerCapita, data = flood2))

summary(lm(peopleDead ~ lifeExp, data = flood2))

summary(lm(peopleDead ~ HDI + lifeExp, data = flood2))



```


```{r}

?get_map

library(ggplot2)
library(maps)

# First (and most annoying) task - get matching state and county variables 
# for both datasets.  And unfortauntely it's not quite right, as you can
# see from the finish product - some counties are missing.
unemp <- read.csv("unemployment09.csv", header = F, stringsAsFactors = F)
names(unemp) <- c("id", "state_fips", "county_fips", "name", "year", 
  "?", "?", "?", "rate")
unemp$county <- tolower(gsub(" County, [A-Z]{2}", "", unemp$name))
unemp$state <- gsub("^.*([A-Z]{2}).*$", "\\1", unemp$name)

county_df <- map_data("county")
names(county_df) <- c("long", "lat", "group", "order", "state_name", "county")
county_df$state <- state.abb[match(county_df$state_name, tolower(state.name))]
county_df$state_name <- NULL

state_df <- map_data("state")

# Combine together 
choropleth <- merge(county_df, unemp, by = c("state", "county"))
choropleth <- choropleth[order(choropleth$order), ]
# Discretise rate to use with Brewer colour scheme - many options here
# choropleth$rate_d <- cut_number(choropleth$rate, 5)
# choropleth$rate_d <- cut_interval(choropleth$rate, 5)
# Nathan's choice is a little odd:
choropleth$rate_d <- cut(choropleth$rate, breaks = c(seq(0, 10, by = 2), 35))

# Once you have the data in the right format, recreating the plot is straight
# forward.

ggplot(choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = rate_d), colour = alpha("white", 1/2), size = 0.2) + 
  geom_polygon(data = state_df, colour = "white", fill = NA) +
  scale_fill_brewer(pal = "PuRd")




map.dat <- map_data("world")
ggplot() + geom_polygon(aes(lat, group=group), fill="grey65", data=map.dat) + theme_bw() + theme(axis.text = element_blank(), axis.title=element_blank())
points(flood$centroidX,flood$centroidY, col="red", pch=16)
?ggpoint
library(OpenStreetMap)
library(ggplot2)
map <- openmap(c(70,-179),
               c(-70,179),zoom=1)
map <- openproj(map)


reclat <- c(50,20,30,40)
reclong <- c(30,40,30,50)         
autoplot(map) + geom_point(aes(x=reclong,y=reclat))

?map
map <- get_map()
ggmap(map)


map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
points(visit.x,visit.y, col="red", pch=16)



map =get_map("world",maptype= "satellite",
  zoom = 1)
ggmap(map)


mapImageData <- get_map(
  color = "color", # or bw
  maptype = "satellite",
  zoom = 1)

m = get_map("World")
ggmap(m)

ggmap(mapImageData)

pathcolor <- "#F8971F"

ggmap(mapImageData,
  extent = "device", # "panel" keeps in axes, etc.
  ylab = "Latitude",
  xlab = "Longitude",
  legend = "right") +
  geom_path(aes(x = Longitude, # path outline
  y = Latitude),
  data = gps,
  colour = "black",
  size = 2) +
  geom_path(aes(x = Longitude, # path
  y = Latitude),
  colour = pathcolor,
  data = flood,
  size = 1.4) # +
# labs(x = "Longitude",
#   y = "Latitude") # if you do extent = "panel"

```




```{r}
workdir = "/Users/garyair/Desktop/Dropbox/Columbia/EDA/P2/Edav-project-2/Edav-project-2/Data/"
setwd(workdir)

ncname <- "NOAA_Daily_phi_500mb"
ncfname <- paste(ncname, ".nc", sep = "")
dname <- "tmp"  # note: tmp means temperature (not temporary)

# open a NetCDF file
ncin <- nc_open(ncfname)
print(ncin)


library(lattice)
data(barley)
barley
dotplot(variety~yield | site, data = barley, panel = panel.superpose, group = year, pch = c(1,3))
data(quakes)
names(quakes)

xyplot(lat~long | depth, data = quakes, layout = c(4,1,1), aspect = 2, main = "Tonga Trench Earthquakes", xlab = "Longitude")

attach(mtcars)
View(mtcars)

# create factors with value labels 
gear.f<-factor(gear,levels=c(3,4,5),
  	labels=c("3gears","4gears","5gears")) 
cyl.f <-factor(cyl,levels=c(4,6,8),
   labels=c("4cyl","6cyl","8cyl")) 

# kernel density plot 
densityplot(~mpg, 
  	main="Density Plot", 
  	xlab="Miles per Gallon")

# kernel density plots by factor level 
densityplot(~mpg|cyl.f, 
  	main="Density Plot by Number of Cylinders",
   xlab="Miles per Gallon")

# kernel density plots by factor level (alternate layout) 
densityplot(~mpg|cyl.f, 
  	main="Density Plot by Numer of Cylinders",
   xlab="Miles per Gallon", 
   layout=c(1,3))

# boxplots for each combination of two factors 
bwplot(cyl.f~mpg|gear.f,
  	ylab="Cylinders", xlab="Miles per Gallon", 
   main="Mileage by Cylinders and Gears", 
   layout=c(1,3))

# scatterplots for each combination of two factors 
xyplot(mpg~wt|cyl.f*gear.f, 
  	main="Scatterplots by Cylinders and Gears", 
   ylab="Miles per Gallon", xlab="Car Weight")

# 3d scatterplot by factor level 
cloud(mpg~wt*qsec|cyl.f, 
  	main="3D Scatterplot by Cylinders") 

# dotplot for each combination of two factors 
dotplot(cyl.f~mpg|gear.f, 
  	main="Dotplot Plot by Number of Gears and Cylinders",
   xlab="Miles Per Gallon")

# scatterplot matrix 
splom(mtcars[c(1,3,4,5,6)], 
  	main="MTCARS Data")
?map
map("state", ".*dakota", myborder = 0)
map.cities(world.cities,"France")
map('county', 'new york')

data(ozone)
map("state", xlim = range(ozone$x), ylim = range(ozone$y))
text(ozone$x, ozone$y, ozone$median)
box()
if(require(mapproj)) {	# mapproj is used for  projection="polyconic"
  # color US county map by 2009 unemployment rate
  # match counties to map using FIPS county codes
  # Based on J's solution to the "Choropleth Challenge"
  # http://blog.revolutionanalytics.com/2009/11/choropleth-challenge-result.html

  # load data
  # unemp includes data for some counties not on the "lower 48 states" county
  # map, such as those in Alaska, Hawaii, Puerto Rico, and some tiny Virginia
  #  cities
  data(unemp)
  data(county.fips)

  # define color buckets
  colors = c("#F1EEF6", "#D4B9DA", "#C994C7", "#DF65B0", "#DD1C77", "#980043")
  unemp$colorBuckets <- as.numeric(cut(unemp$unemp, c(0, 2, 4, 6, 8, 10, 100)))
  leg.txt <- c("<2%", "2-4%", "4-6%", "6-8%", "8-10%", ">10%")

  # align data with map definitions by (partial) matching state,county
  # names, which include multiple polygons for some counties
  cnty.fips <- county.fips$fips[match(map("county", plot=FALSE)$names,
    county.fips$polyname)]
  colorsmatched <- unemp$colorBuckets [match(cnty.fips, unemp$fips)]

  # draw map
  map("county", col = colors[colorsmatched], fill = TRUE, resolution = 0,
    lty = 0, projection = "polyconic")
  map("state", col = "white", fill = FALSE, add = TRUE, lty = 1, lwd = 0.2,
    projection="polyconic")
  title("unemployment by county, 2009")
  legend("topright", leg.txt, horiz = TRUE, fill = colors)

  # Choropleth Challenge example, based on J's solution, see:
  # http://blog.revolutionanalytics.com/2009/11/choropleth-challenge-result.html
  # To see the faint county boundaries, use RGui menu:  File/SaveAs/PDF
}


library(sp)
library(rworldmap)

# The single argument to this function, points, is a data.frame in which:
#   - column 1 contains the longitude in degrees
#   - column 2 contains the latitude in degrees
coords2continent = function(points)
{  
  countriesSP <- getMap(resolution='low')
  #countriesSP <- getMap(resolution='high') #you could use high res map from rworldxtra if you were concerned about detail

  # converting points to a SpatialPoints object
  # setting CRS directly to that from rworldmap
  pointsSP = SpatialPoints(points, proj4string=CRS(proj4string(countriesSP)))  


  # use 'over' to get indices of the Polygons object containing each point 
  indices = over(pointsSP, countriesSP)

  #indices$continent   # returns the continent (6 continent model)
  indices$REGION   # returns the continent (7 continent model)
  #indices$ADMIN  #returns country name
  #indices$ISO3 # returns the ISO3 code 
}

points = data.frame(lon=c(0, 90, -45, -100, 130), lat=c(52, 40, -10, 45, -30 ))

coords2continent(points)
#[1] Europe        Asia          South America North America Australia  
coords2country(points)

map('usa')
map('france')
map.cities()

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
